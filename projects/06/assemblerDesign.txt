The file should be read from the assembler.c program. Then each line should be passed to the
parser where the parser will split it based on C instruction or A instruction. Then, 
each piece of that line will be fed to the interpretor where the string value will be
matched with its binary op code. If the string value does not exist in the map then it
will be considered either a label or variable. 

We should set a bit to determine whether it is a variable or a label. Also, we need to 
make sure that a reference to a label is not deemed a variable. We do this by first gathering
all the labels and adding them to the symbol table. That way something exists in the map when
we look up the variable. 

In Short: 
  - Assembler.c
    - Reads command line file arg by line
    - Passes that line to the parser
  - Parser.c
    - Legit just reads the line and breaks it into strings depending on the instruction. It 
      does not care what the instruction is besides if it is a C or an A instruction because those
      get parsed differently.
    - Takes a char *line argument which it breaks into the respected dest, comp, jmp, or addr if a instruction
  - Interpretor.c
    - Deals with the comp, jmp, dest, and addr values
    - Then during the parser's second pass the interpretor starts getting actual instructions
      and label references. It is also in this second pass that it will pick up on variables
      because it will see it does not have a corresponding label value. 
    - Interpretor will write the output to the binary file.
    - NOTE** Labels store addresses, remember that
  - SymbolTable
    - Create table that maps the predefined values to numbers (ie R0 == 0)
    - Does a pass through the value
